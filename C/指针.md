# C语言指针

32位处理器，有2^32个内存单元，即4GB。4G是虚拟地址，不是实际的内存大小，因而你的32CPU可以插入一个2G的内存条。

同理，64位处理器有2^64个内存单元，即4G个4GB。这是虚拟地址，不是实际内存大小，实际内存大小可能是插入的8GB内存条，或是16GB内存。

当程序运行时，操作系统会为每个程序分配运行所需的实际内存地址空间，这就是动态```地址转换``` 的过程。

***因而在编程时所说的地址，指的是虚拟地址，即虚拟地址空间。***

#### 64位 VS 32位 处理器

- 当是64位处理器时（AMD，Intel）

  ```c++
  int i = 5;
  long j = long(&j);
  printf("%lx",j);
  //输出结果为：7ffee068f718
  //即只使用了48位虚拟地址，48位虚拟地址相当于256TB
  //但是
  printf("%ld",&i);
  //输出结果为8，即指针变量为8个字节
  ```

  

- 当是32位处理器时，地址空间应该是0x00000001~0xFFFFFFFF，其中0x00000000保留位系统0。64位处理器，也可以通过兼容模式，来编写32位程序。

#### 小端模式与栈空间

以64位处理器(48位实际被利用)为例

```c++
int i = 5;
int j = 9;
printf("%lx\n",long(pi));
printf("%lx\n", long(pj));
/*输出结果为	 7ffee990b718 和 7ffee990b714
说明：
1. int占4个字节 
2.i先定义，j后定义，但是i的地址比j地址大，
则栈空间向低地址方向增长*/

long t = long(pi);
printf("%d\n",*((int *)t)); //将t强转化成int*，然后解引用
// 输出5
t++;
printf("%d\n",*((int *)t)); 
// 输出0
/*说明：
小端模式，即变量的高字节在虚拟内存的低地址空间存储。
*/
```

因而，若一个变量int i=5的地址为0x003a58fe（32位），他有指针变量int * p = &i，则p中存储的值为fe 58 3a 00。

### 虚拟内存地址空间

程序的虚拟地址空间有如下图结构

<div align="middle">
<img src="./images/image003.gif" align="middle">
</div>

- .text，即正文段存储可执行程序的二进制代码。
- .data，即数据段存储程序执行时的常量。
- stack，heap增长方向相反。

### 定义指针

连续定义指针时**注意**

```c++
int a, b; //定义两个整型变量
int *p,q; //注意～～～～～p是整型指针，q是整型变量
//应该定义成
int *p, *q;
```

### 指针与函数参数

一个函数想改变调用者函数中的变量必须用指针。因为不同函数在栈区域都有各自的``` 函数栈空间```，函数栈空间参数传递采用值传递方式，因而 **改变函数内参数的值，不会改变调用参数的值**

若想通过调用函数来改变调用者的值，必须通过```指针```，进行传递。这种通过```参数指针```来修改原函数的参数成为```传出参数```。

```c++
#define OUT
void change(OUT int *p){
    //OUT没有实际意义，只是指明参数p为传出指针
    //作用是通过change函数来改变调用参数的值
}
```



### 堆和栈

- 栈

  程序的变量，函数，都会在栈区域申请空间。此处申请的空间是**虚拟地址空间**，而操作系统将虚拟地址空间的栈空间映射到**物理内存**时，对应的物理空间也是连续的。例如申请一个int a[20]，这80个字节的空间在实际分配到的物理地址也是连续的。

  正因如此，栈空间的分配和使用比较高效。

- 堆

  程序通过malloc开辟的空间属于堆空间，且分配到的堆空间在**虚拟地址空间**是连续的。但是，当操作系统将堆空间映射到实际物理内存地址时，**堆空间由物理上分割的碎片空间拼接而成**。因而对空间的开辟，连续性使用效率会低于栈空间。

 

 

 