# C 语言基础

### C语言优先级

<a href="./C语言优先级.pdf">C 优先级</a>

1. 括号

2. 单目，非，取地址，自增自减，sizeof，强转换类型

3. 算数运算符

4. 关系运算符

5. 逻辑运算符

### 变量的作用域

- 局部变量

  局部变量只在离他定义最近的```{```，```}```内有效。

- 外部变量或全局变量

  外部变量时在函数之外定义的变量。它的作用域为，从函数定义开始到本文件结束。

  应该尽量少的定义全局变量，因为全局变量在内存地址空间中占用的是```数据段```，数据段包括```常量区```，```全局区```等。**不同文件中的全局变量都放在数据段内**因而若是在不同文件中定义同名的全局变量，它们都会被放入```全局区```，从而产生同名错误。此时，需要关键字```extern```。

### 变量的作用时期

- 动态存储：变量被分配后可以被收回，例如**函数的调用与弹栈**，**堆空间的分配和收回**。
- 静态存储：常量区，程序区。
- 可操作变量属性的关键字```auto```，```static```，```register```，```extern```
  - auto为缺省
  - static
    - 修饰局部变量，局部变量就不被放在函数栈内（即不会因为函数的消亡而消失），它会被放在```数据段```中的```静态区```内，并且只被初始化一次。**静态局部变量与全局变量的区别在于，静态局部变量虽然也被放在数据段区域内，但它还是隶属于函数作用域范围内的，也就是说，只有本函数能对他进行操作**。
    - 修饰全局变量，则该变量就从```全局区```，跑到```文件区```，即该变量只在**本文件**有效。
    - 修饰函数，函数只在**本文件**范围内有效。
  - register，令一个变量强制进驻寄存器并让其长期占有寄存器，适用于高频率计算的临时变量。
  - extern
    - 修饰变量，则类似于声明其它地方的变量。其它地方可以指**其他文本中的全局变量或是该文本后面定义的变量位置**
    - 函数，缺省就是extern

### 短路运算

- &&短路与，&非短路与
- ||短路或，|非段路或

如果结果不为2时，打印错误，省略了if等复杂的代码。

```C++
ret!=2 && printf("result error");
```

如果变量var为边界为0～4（包括4）的环时，把则当var为5时，

```c++
int var = 4;
while(1){
	var++;
	var==5&&var=0;
}
```

### switch

注意加break

```c++
switch (expression){
    case 1:
        break;
    case 2:
        break;
    default:
        break;
}
```

### goto

goto 只能在同一函数内部跳转

```c++
goto label；

label: statement;
```

### 数组

- Intel CPU体系对变量存储时用小端存储方式，即低位在前，高位在后。
- 后来ARM CPU 的也推广成小端存储
- IBM，龙芯 CPU还是大端存储
- 定义 
  - 直接定义 
  - 间接定义

```c++
// 直接定义
int a[5]; //中括号内必须是个常量，不能写成int a[i]，即数组的大小不能动态定义
// 间接定义
#define NUM 10;
int b[NUM]={1,2,3,4,5,6,7,8,9,10};
```

- 字符数组

```c++
char a[15] = "Hello World";
char a[20] = "你好中国"; 
/*汉字为GBK编码，每个汉字占两个字节，因而这几个字再加\0，一共占9个字节。
GBK总体编码范围为0x8140~0xFEFE，首字节在 0x81~0xFE 之间，尾字节在 0x40~0xFE 之间，剔除 xx7F 一条线。*/
```

### 字符串函数

- puts(char *)

  ```c++
  char c[10]="hello";
  puts(c); //puts 打印一个字符串（带\0）,puts()默认会打印一个换行符
  ```

- gets(char *)

  ```c++
  char buf[10];
  gets(buf);    /*读取一行输入到buf中，gets与scanf的区别是，
  scanf("%s",buf)读取时，不能读取终端输入的 Hello World,因为
  scanf读取%s时以\0作为分隔符，
  他会把这行输入当作两个输入，一个输入为Hello，然后自动补个\0，
  然后等待下一读取操作(跨过空格)，另一个输入为World；而gets以换行符为分隔符，因而可以读取整行。
  gets读取一行以后会对这行字符串结尾赋\0 */
  ```

- strlen(char *)  in <string.h>

- strcpy(char * to, char * from) , 拷贝的时候会拷贝\0结束符的

- strncpy(char * to, char *from, size_t num); 拷贝前num个字节

- strcat(char * head, char * tail)，拷贝tail到head中

### scanf()缓冲区

当通过终端输入一行数据并用scanf接收时候。

```c
scanf("%d%s%c%d",&i1,str,&c,&i2);
//输入
//15 "Hello" 'R' 23
//在输入结束后，还没按Enter之前，15 "Hello" 'R' 23都在一个关联屏幕的缓冲区
//而不是stdin缓冲区，当按Enter后，这串数据才会被送入stdin缓冲区
//输入结束后被放入输入缓冲区stdin的内容包括
//15，空格，字符串Hello，空格，字符R，空格，数字23，回车换行符
```

scanf读取缓冲区遵循的规则：

- 逐步，一个个的读取与模式匹配的数据，读取一个删除一个。删除的范围是：删除所有最终提取数据之前的缓冲区中的内容。
  - 如上例子，现在stdin缓冲区中包含"15"," ","Hello"," ","R"," ","23","\n"这8个数据。

  - scanf逐一读取缓冲区，第一轮读取15，匹配了%d，返回15并删除缓冲区中的15，结束该轮匹配。

  - 第二轮要读取%s，**scanf函数中除了%c以外，所有匹配开始前都会忽略开始的空格或换行符**。因而该轮读取%s，首先忽略缓冲区中的“ ”，然后再开始读取。一直读取到下一个“ ”前结束，因而返回“Hello”，并在读取完毕后删除“ ”和“Hello”。

  - 第三轮要读取%c，因为scanf()在读取该匹配前不忽略空格和换行符（因为这些符号也属于%c的范围），因而该轮会把“ ”读取出来传递给变量c，并删除缓冲区中的" "，从而造成错误。

    ```c
    //正确的做法是匹配模式中指定一个空格，用来吸收输入
    scanf("%d%s %c%d",i1,str,c,i2);
    ```

- 另一例子，能说明scanf读取缓冲区后删除的范围是，读取内容点到缓冲区开头所有的内容，包括忽略的内容。

- ```c
  int i;
  char a[20]={0};
  scanf("%d",&i);
  printf("%d\n",i);
  gets(a);
  puts(a);
  //输入第一行15，然后enter
  //屏幕打印15
  //准备输入a的值，发现程序已经结束
  ```

  此处的原因是，输入i后，缓冲区中其实保留的是"15","\n"。

  scanf读取%d后删除缓冲区%d之前的所有内容，但是缓冲区中还有一个“\n”。

  因而gets()读取缓冲区时，直接不等你输入，就直接读去了一个"\n"，而gets默认识别的结束符就是"\n"。因而gets直接读取了一个空内容。读取完毕后，gets删除缓冲区中的该"\n"，并用puts输出一个空字符。因而程序不会接收到你的输入。

***综上所述***： scanf，读取时:

1. %c不会忽略空格和换行符
2. 每次读取后只删除读取内容点之前的缓冲区内容。
3. 若读取完毕，缓冲区中还存有"\n"，" "等内容则清除手段有：
   1. 下一轮读取scanf时，根据第2条清除。
   2. 通过fflush(stdin)函数清除。

### 结构体

#### 结构体空间计算

结构体的空间不一定是实际变量所占用的空间，例如

```c++
struct student{
    int num;
    char name[20];
    char gender;
    int age;
};	//定义结构体类型时，结尾一定要有分号。
struct student s1 = {1001,"zhangsan",'M',18};
sizeof(s1)	//返回的不是单个成员所占空间，即4(num)+20(name)+1(gender)+4(age)=29个字节
    　// 其返回的是32个字节，因为gender是char类型的，当它被定义在结构体中间时，为了保证
    //整存整取内存的属性，实际分配给gender的空间依然是4个字节。因为系统是32位的，每一次从内存中
    //读取数据是并行的32位数据，即4个字节。
```

内存的这种分配方式称为--**对齐**

对齐的作用是为了减少内存读取频率，提高CPU工作效率。

因而，优化方法就是把站位大的数据放在结构体的前部，在结构体的结尾再定义小的数据段。

#### 结构体定义

```c
struct student{
    int num;
    char name[20];
    char gender;
    int age;
}s1,s2;
//定义了一个student 结构体，并且初始化了两个结构体变量s1，s2。s1，s2是变量。

typedef struct student{
    int num;
    char name[20];
    char gender;
    int age;
}stu;
//此处定义了一个student结构体，并定义了一个该结构体的别名stu。该处stu不是变量。
```

