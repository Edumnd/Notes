# C 语言基础

### C语言优先级

<a href="./C语言优先级.pdf">C 优先级</a>

1. 括号

2. 单目，非，取地址，自增自减，sizeof，强转换类型

3. 算数运算符

4. 关系运算符

5. 逻辑运算符

### 变量的作用域

- 局部变量

  局部变量只在离他定义最近的```{```，```}```内有效。

- 外部变量或全局变量

  外部变量时在函数之外定义的变量。它的作用域为，从函数定义开始到本文件结束。

  应该尽量少的定义全局变量，因为全局变量在内存地址空间中占用的是```数据段```，数据段包括```常量区```，```全局区```等。**不同文件中的全局变量都放在数据段内。**因而若是在不同文件中定义同名的全局变量，它们都会被放入```全局区```，从而产生同名错误。此时，需要关键字```extern```。

### 变量的作用时期

- 动态存储：变量被分配后可以被收回，例如**函数的调用与弹栈**，**堆空间的分配和收回**。
- 静态存储：常量区，程序区。
- 可操作变量属性的关键字```auto```，```static```，```register```，```extern```
  - auto为缺省
  - static
    - 修饰局部变量，局部变量就不被放在函数栈内（即不会因为函数的消亡而消失），它会被放在```数据段```中的```静态区```内，并且只被初始化一次。**静态局部变量与全局变量的区别在于，静态局部变量虽然也被放在数据段区域内，但它还是隶属于函数作用域范围内的，也就是说，只有本函数能对他进行操作**。
    - 修饰全局变量，则该变量就从```全局区```，跑到```文件区```，即该变量只在**本文件**有效。
    - 修饰函数，函数只在**本文件**范围内有效。
  - register，令一个变量强制进驻寄存器并让其长期占有寄存器，适用于高频率计算的临时变量。
  - extern
    - 修饰变量，则类似于声明其它地方的变量。其它地方可以指**其他文本中的全局变量或是该文本后面定义的变量位置**
    - 函数，缺省就是extern

### 短路运算

- &&短路与，&非短路与
- ||短路或，|非段路或

如果结果不为2时，打印错误，省略了if等复杂的代码。

```C++
ret!=2 && printf("result error");
```

如果变量var为边界为0～4（包括4）的环时，把则当var为5时，

```c++
int var = 4;
while(1){
	var++;
	var==5&&var=0;
}
```

### switch

注意加break

```c++
switch (expression){
    case 1:
        break;
    case 2:
        break;
    default:
        break;
}
```

### goto

goto 只能在同一函数内部跳转

```c++
goto label；

label: statement;
```

### 数组

- Intel CPU体系对变量存储时用小端存储方式，即低位在前，高位在后。
- 后来ARM CPU 的也推广成小端存储
- IBM，龙芯 CPU还是大端存储
- 定义 
  - 直接定义 
  - 间接定义

```c++
// 直接定义
int a[5]; //中括号内必须是个常量，不能写成int a[i]，及数组的大小不能动态定义
// 间接定义
#define NUM 10;
int b[NUM]={1,2,3,4,5,6,7,8,9,10};
```

- 字符数组

```c++
char a[15] = "Hello World";
char a[20] = "你好中国"; 
/*汉字为GBK编码，每个汉字占两个字节，因而这几个字再加\0，一共占9个字节。
GBK总体编码范围为0x8140~0xFEFE，首字节在 0x81~0xFE 之间，尾字节在 0x40~0xFE 之间，剔除 xx7F 一条线。*/
```

### 字符串函数

- puts(char *)

  ```c++
  char c[10]="hello";
  puts(c); //puts 打印一个字符串（带\0）,puts()默认会打印一个换行符
  ```

- gets(char *)

  ```c++
  char buf[10];
  gets(buf);    /*读取一行输入到buf中，gets与scanf的区别是，
  scanf("%s",buf)读取时，不能读取终端输入的 Hello World,因为
  scanf读取%s时以\0作为分隔符，
  他会把这行输入当作两个输入；而gets以换行符为分隔符，因而可以读取整行。
  gets读取一行以后会对这行字符串结尾赋\0 */
  ```

- strlen(char *)  in <string.h>

- strcpy(char * to, char * from) , 拷贝的时候会拷贝\0结束符的

- strncpy(char * to, char *from, size_t num);

- strcat(char * head, char * tail)，拷贝tail到head中

### 结构体

#### 结构体空间计算

结构体的空间不一定是实际变量所占用的空间，例如

```c++
struct student{
    int num;
    char name[20];
    char gender;
    int age;
};	//定义结构体类型时，结尾一定要有分号。
struct student s1 = {1001,"zhangsan",'M',18};
sizeof(s1)	//返回的不是单个成员所占空间，即4(num)+20(name)+1(gender)+4(age)=29个字节
    　// 其返回的是32个字节，因为gender是char类型的，当它被定义在结构体中间时，为了保证
    //整存整取内存的属性，实际分配给gender的空间依然是4个字节。因为系统是32位的，每一次从内存中
    //读取数据是并行的32位数据，即4个字节。
```

内存的这种分配方式称为--**对齐**

对齐的作用是为了减少内存读取频率，提高CPU工作效率。

#### 结构体定义

```c
struct student{
    int num;
    char name[20];
    char gender;
    int age;
}s1,s2;
//定义了一个student 结构体，并且初始化了两个结构体变量s1，s2。s1，s2是变量。

typedef struct student{
    int num;
    char name[20];
    char gender;
    int age;
}stu;
//此处定义了一个student结构体，并定义了一个该结构体的别名stu。该处stu不是变量。
```

