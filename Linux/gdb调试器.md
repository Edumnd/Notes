# gdb调试器简介

在执行gdb调试之前，需要对编译命令添加```-g```参数

添加```-g```参数以后，程序会变得很臃肿，因而只适用于调试阶段。

```bash
gcc main.c -o main -g
# 对main.c进行-g参数编译，该参数用于调试
# 生成可用于调试的main，ELF可执行程序
```

### gdb调试

#### gdb 打开调试

通过gdb 可调试程序名，进入gdb模式

```bash
gdb main
# 进入gdb调试模式
```

#### gdb 命令

- l 命令，显示代码

- **b 命令，添加断点**

  ```bash
  b main # 在main函数处打一个断点
  b 4    # 在第四行打一个断点
  ```

- tb，添加临时断点，只执行一次

- info b，查看断点情况

- delete 断点号，删除某个断点

- disable 断点号，断点失效

- enable 断点号，断点生效

- r 命令，运行程序

- n 命令，当程序运行时，且有断点时，n会执行下一条代码

- c 命令，continue，直接跳转到下一个断点处。

- s 命令，跳入某函数

- f 命令，跳出某函数

- p 命令，打印值

  ```bash
  p i # 打印变量i的值
  p &i # 打印变量i的地址值
  ```

- **bt 命令，查看调用堆栈情况**

- show args 命令，查看系统参数

- set args 命令，设置系统参数

- **x <n/f/u>，显示内存情况，n表示查看的单位个数，f表示以什么格式显示，u表示单位大小**

  ```bash
  x /20xb &i # 显示变量i地址后面20个字节大小的内存情况，以16进制格式显示
  ```

- attach 进程ID，多线程动态调试并行程序

### 定位段错误

段错误，即segmentation fault会造成程序崩溃。程序退出运行。因而无法用运行模式gdb调试程序。

例如：

```c
#include <stdio.h>
int main(){
    int *p=NULL;
    *p = 1; //为一个空指针赋值1，程序会崩溃。
    return 0;
}
```

每个程序在崩溃时，会产生一个core 文件（类似于黑匣子），从而可以利用core来定位错误发生位置。

**如果需要定位段错误，在程序编译的时候必须加上```-g```参数**，否则程序core文件（二进制）无法定位到源代码的位置。



#### ulimit 命令

- ```ulimit -a ```可以查看系统默认大小配置。

- ulimit -a 可以看到默认core 文件大小为0，即不产生core文件。

- 设置ulimit

- ```bash
  ulimit -c unlimited
  ```

#### 执行程序

当core file size 设定大小后（一般为无限大），执行程序发生段错误后，在当前目录下会产生一个core文件

#### 调用gdb查看段错误

```bash
gdb main core #main为生成的可执行二进制文件，core为core文件
```

