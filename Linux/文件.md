# Linux 文件

Linux 中的文件操作基于**文件描述符**，文件操作符就是代表文件的整数。

C 语言中的文件操作基于**文件指针**

### Linux 一般命令操作

- 更改权限chmod

- ```c
  #include<sys/stat.h>
  int chmod(const char* path, mode_t mode);
  // 修改path位置的文件为mode 权限
  // mode为八进制整数
  ```

- 获取当前路径pwd

  ```c
  #include<unistd.h>
  char * getcwd(char *buf, size_t size);
  // 获取当前路径，存储到buf中
  // buf为我们自己申请的空间首地址，size为buf的大小
  ```

  - 若我们传递一个确切的我们自己申请的buf地址给getcwd函数，则该函数会把当前工作路径填写到buf中，返回值也是buf这个首地址。
  - 若我们传递的是getcwd(NULL,0)，则getcwd函数会自己申请一个空间，用于存储工作路径，然后用char * 返回。这种有函数自己申请空间的方式，只适用于不对buf中的路径内容进行修改和不对buf进行过长时间保存的情况，即只适用于临时打印或使用当前路径。因为**不确定该空间什么时候会被回收，以及空间大小**。

- 改变当前路径chdir

- ```c
  #include<unistd.h>
  int chdir(const char *path);
  ```

- 创建文件夹和删除文件夹

  ```c
  // 创建文件夹
  #include <sys/stat.h>
  #include <sys/types.h>
  int mkdir(const char *pathname, mode_t mode);
  
  // 删除文件夹  只能删除空目录
  #include <unistd.h>
  int rmdir(const char *pathname);
  ```

  

### Linux 目录文件

- 打开浏览文件夹

- ```c
  #include <sys/types.h>
  #include <dirent.h>
  DIR *opendir(const char *name); //打开一个目录，返回DIR结构的目录指针
  
  #include <dirent.h>
  struct dirent *readdir(DIR *dirp);	//读取目录上一个文件结构
         
  struct dirent {	//返回dirent指针              
      ino_t          d_ino;       /* 文件的id */               
      off_t          d_off;       /* 文件夹下记录的文件是由一个节点链表串联起来的
      				该处记录的是节点相对于下一个节点在磁盘上的偏移量*/           		
      unsigned short d_reclen;    /* Length of this record */
      unsigned char  d_type;      /* Type of file; not supported
      char           d_name[256]; /* Null-terminated filename */
  };
  void rewinddir(DIR * dir);  // 重新定位到目录文件头，用于重新开始搜索
  void seekdir(DIR * dir, off_t offset); // 用来设置目录流当前索引位置
  off_t telldir(DIR * dir); // 返回目录流当前读取位置
  int closedir(DIR * dir);  // 关闭目录流
  ```



Inode节点表示文件节点号码，在整个**Linux文件系统中，每一个文件对应唯一一个Inode**，即Linux文件以Inode识别文件

通过命令，ls -i 来查看文件的inode信息

```bash
ls -i # 显示inode
ls -l # 显示文件信息，第一列为权限，第二列尾链接的文件名个数
# 该个数指示有多少个文件名指向该inode（其中也包括‘.’文件名）。
ln file1 file2 # 建立硬链接，使得两个文件名file1，file2同时指向同一个inode
# 此时第二列（硬链接数）加一。如果此时删除一个文件名，则硬链接数就减一，当硬链接
# 数目减少到0，此时文件真正被删除。
```

### Linux 文件状态信息

- Linux每一个文件都有一个状态信息存储在```struct stat```结构体中

  ```c
  struct stat {
     dev_t     st_dev;         /* 如果是设备，返回设备描述符，否则返回0*/
     ino_t     st_ino;         /* 文件节点号 */
     mode_t    st_mode;        /* 文件类型 */
     nlink_t   st_nlink;       /* 硬链接数 */
     uid_t     st_uid;         /* 用户ID */
     gid_t     st_gid;         /* 组ID */
     dev_t     st_rdev;        /* 设备类型 */
     off_t     st_size;        /* 文件大小，字节大小 */
     blksize_t st_blksize;     /* 块大小 */
     blkcnt_t  st_blocks;      /* 块数目 */
     struct timespec st_atim;  /* 最后访问时间 */
     struct timespec st_mtim;  /* 最后修改时间 */
     struct timespec st_ctim;  /* 最后权限修改时间 */
  };
  
  ```

-  mode_t，文件类型为```无符号整型数```，低9位表示文件权限，高4位表示文件类型

  - 高4位确定文件类型，可以用如下宏定义函数确定文件类型

  - ```c
    S_ISLNK(mode)	//判断是否是符号链接
    S_ISREG(mode)	//判断是否是普通文件
    S_ISDIR(mode)	//判断是否是目录
    S_ISCHR(mode)	//判断是否是字符型设备
    S_ISBLK(mode)	//判断是否是块设备
    S_ISFIFO(mode)	//判断是否是命名管道
    S_ISSOCK(mode)	//判断是否是套接字
    ```

    

- stat函数

- ```c
  int stat(const char *pathname, struct stat *statbuf);
  // 文件路径名，以及自己定义的一个statbuf空间指针，用于接收文件状态信息
  ```

- 其他函数

- ```c
  struct passwd *getpwuid(uid_t uid);
  // 通过用户id获取用户配置文件信息
  struct group *getgrgid(gid_t gid);
  // 通过组id获取用户组信息
  ```

### LInux文件描述符

文件描述符是linux管理文件的结构体，大小为0～1023。这1024个描述符对应linux上相应的文件描述信息的结构体，因而可以通过一个整型变量来表示对应的文件。

- 0，标准输入
- 1，标准输出
- 2，标准错误输出

#### 打开、创建、关闭文件

- 打开创建文件open

- ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  
  int open(const char *pathname, int flags);	//打开一个文件，传入一个路径，一个打开标志
  int open(const char *pathname, int flags, mode_t mode); 
  //多传入一个mode，mode指读写权限，用于创建新文件时使用。
  //flags是不同位的整数
  // O_RDONLY 只读打开
  // O_WRONLY 只写打开
  // O_RDWR	读写打开
  // O_CREAT	如果文件不存在，创建文件
  // O_EXCL	如果文件存在，强制文件打开失败
  // O_TRUNC	如果文件存在，将文件截断至0打开
  // O_APPEND	追加方式打开，打开后每次调用write，文件指针先移动到文件尾，用于多进程写。它与WR区别类似于标准C的写与追加的区别。
  // O_NONBLOCK 非阻塞方式打开， 无论有无数据读取或等 待，都会立即返回进程之中。
  // O_SYNC	同步打开文件，只有当数据被真正写入物理设备才返回；
  // 该模式即非缓冲模式。不需要做内存空间映射，没有缓冲区模式。
  ```

- 文件的读写read，write

- ```c
  #include <unistd.h>
  ssize_t write(int fd, const void *buf, size_t count);
  ssize_t read(int fd, void *buf, size_t count);
  // 文件描述符，写的内容首地址buf，字节大小count
  // 读时，读完整个文件返回0，失败或错误返回-1，其他情况返回读取的字节数
  ```

- 文件截取ftruncate

- ```c
  #include <unistd.h>
  #include <sys/types.h>
  int ftruncate(int fd, off_t length);
  // 文件描述符，文件截取偏移字节数。当源文件中总字数小于length，
  // 则向源文件中补0直到截取位置
  ```

- 光标位移lseek

- ```c
  #include <sys/types.h>
  #include <unistd.h>
  off_t lseek(int fd, off_t offset, int whence);
  // offset 是参考目标，可以是
  // SEEK_SET 开头
  // SEEK_CUR 当前
  // SEEK_END 结尾
  // whence 表示距离参考目标的距离，字节数
  // lseek的返回值为off_t，即光标距离文件开头的字节数。
  // 因而lseek(fd,SEEK_CUR,0)的返回值为当前光标的位置，等价于标准C下的ftell函数
  ```

- 获取文件信息fstat

- ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>
  int fstat(int fd, struct stat *statbuf);
  // 通过文件描述符fd获取文件stat信息
  ```


### 文件描述符的复制

文件描述符的复制，需要用到 **系统调用(内核地址空间)** 函数，```dup```和```dup2```。

通常文件描述符```fd```的复制用来重定向```stdin```，```stdout```，```stderr```。

文件描述符本来就是整型数。在Linux下，系统创建一组数据结构用于保存文件句柄信息，这组数据结构有其特定的**相对位置**，因而Linux就可以简单的通过整型数来制定具体某一个文件句柄的操作。**这就是文件操作符的基本原理**。

- stdin 对应操作符0，stdout对应1，stderr对应2.

- dup 函数，用来拷贝一个文件描述符。它拷贝一个```source```文件描述符所指向的文件句柄数据结构，但是占用一个新的文件描述符号。（从小到大，哪个描述符号没有被使用，就用哪个）。

- dup2 函数，可以指定一个特定的新文件描述符编号，原理同dup函数。

- ```c
  #include<unstd.h>
  int dup(int oldfd);
  int dup(int oldfd, int newfd);
  ```

- **注意**：文件描述符的复制dup，完全不同于直接给变量赋值```newfd=oldfd```。这种赋值，只是两个变量值的直接拷贝而已，而在Linux系统调用空间中，新```newfd```指向的那个数据结构还没有被复制成```oldfd```指向的那个数据结构。因而**对变量fd的操作没有任何意义，真正有意义的是，对fd所指向的数据结构进行操作**，从而有了dup函数。同时```newfd=oldfd```这种方法，如果关闭了fd，即```close(newfd)```，整个文件句柄就被关闭了，因为系统数据结构中文件**打开计数器**只有1。