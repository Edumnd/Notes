# Linux 线程

### 进程VS线程

#### 进程

进程是资源分配的基本单位，每一个进程都有自己的**内存地址空间**，即有自己的**程序段，堆栈段，内核空间，数据段**。即进程的```fork```开辟了全新的```PCB```（虽然该PCB部分内容会继承父进程），因而这个全新的PCB就会开辟相应的新的内存地址空间。

因而进程切换需要很**复杂的进程上下文切换**

#### 线程

线程是基本调度单位，共享进程的**内存地址空间**，只拥有自己的**线程id**和**线程栈空间**

#### 上下文切换

上下文切换主要是对CPU的执行流程进行切换，需要更改的是内核中管理调度的一些结构体

- PC指针（程序计数器）
- 内核维护的TLB：TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。简单来说，就是**虚拟内存空间映射到实际物理内存的转换表**。这个表的作用就是缓存按照一定算法缓存的页表，页目录（最近访问优先替换算法等）。这样在内存地址转换时，就不用查找页表，因而算是一个cache。若地址映射时有miss，才实际查找物理页表。**PCB，上下文切换，意味着所有TLB页表miss**，因而需要很长时间加载。
- 上下文切换最费时间的就是**TLB的刷新**，因为程序切换了，原先的TLB就不再使用新的PCB了，因而需要装载新的转换表到TLB中。这种加载很费时间。

### 基本概念

- 一个进程中即```PCB```中会维护一个```tasks_struct```的结构体，用来记录所有该进程下所包含的线程集合。

- 最主要的线程为main线程

- 每个线程都有自己独立的```栈空间```

- 线程切换不用切换上下文

- 线程实际上类似于函数，不同函数有不同函数栈，线程也有自己的线程栈空间，只不过线程可以被单独调度，被并发的分配时间片。若函数也能并发执行，拿它也就变成了线程。

- 因而，线程的创建第一步**创建线程起始入口点**，也就是找一个函数，把它设置为一个线程，使得这个函数拥有被单独调度的权限。

- 由于线程使用的是同一内存地址空间，因而可以实现数据的共享（除了自己的栈内存），因而若是同一进程生成的线程之间传递数据，不需要**共享内存(shmget)**

- ```main线程```比较特殊，它的退出会造成该进程的退出，从而结束整个线程簇。

  - 在进程的创建活动中创建者与被创建者之间是有层级关系的。
  - 在线程之间，线程与线程没有层级关系，所有线程都是同级关系。（除了main线程，其实main线程与各个线程也是同级关系，只是它比较特殊，它的退出会通知系统回收资源，销毁PCB，从而结束整个线程簇，即进程）

- 使用POSIX标准线程库，在编译时需要显示连接库，即在编译时，需显示添加```-lpthread```参数。

- 当看查看线程是用到的不是ps -elf而是

- ```bash
  ps -eLF
  ```

- 或者在虚拟设备文件下查看

- ```bash
  cd /proc/进程id/task/ 
  # task表示线程目录
  ```


#### 用户级线程和核心级线程

- 用户级别线程：线程只允许在单核上调度，不允许跨核调度
- 核心级线程：有系统维护，可以允许跨核心调度
- Linux的线程是通过用户级库来实现的，它使用的是POSIX标准下的```中间层nptl线程库```中的pthread来创建线程。

### 线程的创建、设置和结束

#### 线程创建

线程创建用函数```pthread_create```

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
// 这就是创建线程的POSIX标准库的创建方法
// ----start_routine参数表示，需要被升格为线程的函数地址首地址。
// 该函数从而拥有单独调度的权限。当此函数执行完毕，则线程结束
// ----thread 参数表示，我们需要设置一个pthread_t结构体，来记录该线程的创建
// 若该创建函数执行成功，则它就会把创建该进程的信息填写到该结构体中，
// 其中包括线程id
// ----attr，参数表示创建线程的属性
// ----arg, 参数类似于main函数的arg，该函数会把这个arg参数传递给start_routine函数
```

#### 线程结束和返回

线程的不能用exit()，因为exit会直接结束进程（等价于执行函数时直接调用exit（），他会直接终止该函数，并结束进程）。也就是说exit（）会结束进程，而不但是本线程

- 线程结束用```pthread_exit```函数

- 线程取回返回值信息用```pthread_join```函数，该函数和wait类似，调用该函数会阻塞。等待有线程pthread_exit返回

```c
#include <pthread.h>

void pthread_exit(void *retval);
// retval 代表线程退出后提供的返回值，该值可以自由设置，从而指示那种线程退出
// 返回值可以通过pthread-join拿到，从而了解该线程是如何返回的

int pthread_join(pthread_t thread, void **retval);
```

```pthread_exit```的使用场景

```c
void * ppp(void * p ){
    char * pstr = (char *)malloc(20);
    pthread_exit((void *)pstr);
}// 定义了一个子线程函数，该函数内部开辟了一个malloc字符堆空间。
// 该对空间的其实地址pstr存储在ppp函数栈中。
int main(){
    //.....
    char * p ;// 定义了一个变量p，该变量的类型为一个字符指针。
    // 但是p在main函数栈中，此处想让该p获得子线程的堆空间地址。用join函数
    pthread_join(thread,(void**)&p);
    // 将p的地址传给pthread_join函数，则pthread_join函数就能更改p的值
    // 从而使得main栈中的p值改变，并等于pthread_exit的返回值，其内部逻辑就是
    // *p=pstr，即把exit的参数复制给*p(二级指针)
    // 从而main该线程就获得了ppp线程开辟的堆空间
}
```

更多的```pthread_exit```使用场景是返回***整型数***，来标识返回状态

### 线程的异步

- 线程的异步不会像进程那样通过发送**信号**来实现

- 线程的异步主要是通过```pthread_cancel```来实现

- ```pthread_cancel```函数表示通知同一线程簇中的某一线程**准备结束**

- 子线程可以cancel任意线程除了main线程；main 线程课可以cancel任意线程

- ***实际上cancel就是：线程级别的信号发送***

- 如何处理cancel，由线程内部自行决定

- cancel的接收程序是```pthread_cleanup_push```和```pthread_cleanup_pop```函数

- ```c
  #include <pthread.h>
   void pthread_cleanup_pop(int execute);
  // 弹栈函数
  // 该函数是宏定义函数
  
  void pthread_cleanup_push(void (*cleanup_routine)(void *), void *arg);
  // 压栈函数
  // 从此处可以看到，第一个参数cleanup_routine为一个钩子函数
  // 它将穿进来的函数首地址，压入cleanup函数栈
  // 该函数是宏定义函数
  ```

  - 当线程发送了cancel信号给某一个线程时，该线程会准备退出。

  - 在准备退出之前，执行指针会跳转到一个**函数栈空间**

  - 在退出之前，该线程检查该函数栈是否为空，若不为空，则依次执行被压栈的各个函数后退出。

  - ```pthread_cleanup_pop```和```pthread_cleanup_push```函数就是向该栈中**添加和删除**函数的接口

  - ```c
    // 清理函数
    // 清理函数用于清理子线程开辟的资源的释放
    // 该函数会被压入清理栈中
    void clean_func(void *p){
        free(p);
    }
    // 子线程执行函数
    void * thread_func(void * p1){
        char * pstr = malloc(20);
      
        // 设置压栈函数
        pthread_cleanup_push(clean_func,pstr);
        // 该函数设置了需要被压栈的函数，并把该子线程开辟的
        // 开辟的资源空间的首地址pstr，当作参数传递给clean_func
        //....执行子函数其他内容
        // 返回程序
        pthread_exit((void*)0); //表示执行成功，线程正常退出
        // 此处也可以是return 方式退出
        // 如果是以return 方式退出，cleanup_pop需要写到return之前
        // 并且需要紧邻return
        pthread_cleanup_pop(1);
    	// ******return 和 pthread_exit的区别是：
        // ******return 是C语言的普通返回，没有使用到pthread框架。
        // ******pthread_exit使用到该框架。
        // ******该框架告诉线程，如果程序结束，无论是正常流程走到exit处
        // ******还是接收到cancel信号，异步退出，该线程都会扫描cleanup函数栈，
        // ******并执行其内部的函数。然后再真正退出
        // ******return 没有该机制，线程执行到return会直接退出。
        // ******因而如果有清理函数已经被压入栈中，
        // ******程序走到return处，就会直接退出，不执行被压栈的函数
        // ******但是如果线程没有走到return，遇到了pthread_cancel
        // ******程序就会遵从该框架设定，执行栈函数。
        // ******简而言之：
        // ******线程遇到cancel信号，或是执行到pthread_exit，则去执行pop
        // ******遇到return，直接返回。所以若要用return，需将pop(1)，
        // ******放到return之前
        
        
        
        // ^^^^^^因为push和pop必须是成对出现。
        // ^^^^^^pop(1)表示弹栈，并执行该压栈函数
        // ^^^^^^pop(0)表示弹栈，但不执行压栈函数
        
    }
    ```

    **此处的重点是**：return和exit的区别；以及pop(0),pop(1)的区别，以及pop的位置




