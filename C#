const是C#中定义常亮的关键字。

使用变量分为3步：声明、赋值、使用。

Console.WriteLine("我今天吃{0}，明天吃{1}。",today,tomorrow);

字符类型 char ，存储用 '' (单引号)括起来的一个字符，例如：char sex='男';//存储性别
字符串类型 string ，存储用“”（双引号）括起来的一串字符，例如：string address="北京市宣武区牛街北口";//存储地址
整数类型 int ，存储整数，例如：int age=23;//存储年龄
双精度浮点型 double ，存储小数，例如：double salary=7991.63;//存储工资
以上四种是最常用的数据类型，其他常用类型，我们会随着课程深入慢慢介绍。

自动类型转换：2种不同类型的数据运算，低精度类型会自动转换为较高精度的类型。

强制类型转换：无法自动转换为我们需要的类型，可以用强制类型转换，比如上例可以这样完成：int i=(int)3.0;

C#标识符的命名规则
程序中的变量名、常量名、类名、方法名，都叫做标识符。
C#有一套标识符的命名规则，如果命名时不遵守规则，就会出错。这套规则简单说有下面三条：
  ①标识符只能由英文字母、数字和下划线组成，不能包含空格和其他字符。
   错误的标识符声明：string $user; //错在使用了其他字符
  ②变量名不能用数字开头。
   错误的标识符声明：double 6h;//错在用数字开头
  ③不能用关键字当变量名。
   错误的标识符声明：char static ;//错在用关键字static做变量名

C#的算术运算符（一）
计算机程序，当然少不了“计算”，要计算就必须了解运算符。今天，我们先学习算术运算符中的加、减、乘、除。

加：+ 。加号有2个用途：当用加号连接两个数字时，会计算出这两个数字的和。比如：Console.WriteLine(9+2.2);//输出11.2
另一种情况，当加号两边包含字符串的时候，会把两边的表达式连接成新的字符串。比如：Console.WriteLine(9+"2.2");//输出92.2，因为"2.2"是字符串，所以9也被转换为"9"，+起的作用是连接字符串

减：- 。减号的作用就是减法。比如：Console.WriteLine(15-23);//输出-8

乘：* 。乘号的作用是求2数的乘积。比如：Console.WriteLine(0.8*3);//输出2.4

除：/ 。除号的作用是求2数相除的商。比如：Console.WriteLine(2/0.5);//输出4.0
但是，2个整数相除，结果仅保留整数部分，小数部分会被舍去。Console.WriteLine(5/10);//输出0


C#的算术运算符（二）
这一节我们学习取余运算符。C#中的取余运算符就是%。
上一节学习的除号，作用是求2个数字相除的商，而取余运算符%的作用是求两个数字相除的余数。比如：
Console.WriteLine(19/5);//求19除以5的商，输出3
Console.WriteLine(19%5);//求19除以5的余数，输出4（商3余4）

编程中，%常常用来检查一个数字是否能被另一个数字整除。比如下面的代码片段：
int number = 29;
Console.WriteLine(number%2);//求number除以2的余数
如果输出0,表示没有余数，即number能够被2整除（是偶数）；如果输出1，表示有余数，即number不能被2整除（是奇数）。

C#的算术运算符（三）
++，叫做自加运算符。比如你今年18岁，明年长了一岁，用代码写出来是这样：age++;与age=age+1;作用相同，都是变量的值+1。
--，叫做自减运算符。

另外，age++;与age--;也可以写作++age;或--age;
但请注意：如果与其他运算在同一语句中，++写在变量前面或后面，算法不一样，请看下例：
Console.WriteLine(age++);作用等同于下面两句：
  Console.WriteLine(age);//先打印
  age=age+1;//后自加

Console.WriteLine(++age);作用等同于下面两句：
  age=age+1;//先自加
  Console.WriteLine(age);//后打印

C#的比较运算符
比较数字大小，或者比较数字相等的运算符是比较运算符。C#中的比较运算符有：
= 等于, != 不等于, > 大于, < 小于, >= 大于等于, <= 小于等于
注意：表示两个值相等的“等于”是由2个“=”组成的。
比较运算的结果，都是布尔类型（ bool ），bool类型我们是第一次提到，它表示逻辑上的真(成立)与假(不成立)。真与假用关键字 true 和 false 表示。

C#的逻辑运算符（一）
逻辑运算符用来连接多个 bool 类型表达式，实现多个条件的复合判断。C#中的逻辑运算符包括：逻辑非( ! )、逻辑与( && )、逻辑或( || )。

逻辑非用来对某一个 bool 类型表达式取反，即“真变假”或“假变真”。请看下面的代码：
Console.WriteLine(1 > 0);//条件表达式为true，输出True
Console.WriteLine(!(1 > 0));//用逻辑非对条件表达式取反，输出False

逻辑与用来判断 2 个 bool 类型表达式是否同时为 true 。请看下面的代码：
int x = 5, y = 2;//同时声明2个int型变量并赋值
Console.WriteLine(x>3 && y>3);//判断x>3和y>3是否同时为true，由于y>3为false，所以整个表达式为false
只有当&&两边的表达式均为 true 时，整个表达式才为 true ；若任意一个表达式为 false ，整个表达式即为 false 。

逻辑或用来判断2个 bool 类型表达式中是否有一个为 true 。请看下面的代码：
int x = 5, y = 2;//同时声明2个int型变量并赋值
Console.WriteLine(x>3 || y>3);//判断x>3和y>3是否有一个为true，由于x>3为true，所以整个表达式为true
只要||两边的表达式有一个为 true ，整个表达式即为 true ；若两边的表达式均为 false ，整个表达式为 false 。

对比一下，就是说： && 运算符，两边同真才算真，一边为假就算假； || 运算符，一边为真即为真，两边同假才是假。


C#的赋值运算符
前面，我们已经学过一个赋值运算符“=”，这次我们学习一下其他的赋值运算符：

加赋值“+=”：先加后赋值。请看下面的例子：int x=5; x += 2;//这句等同于x=x+2;执行后，x的值为7
减赋值“-=”：先减后赋值。请看下面的例子：int x=5; x -= 2;//这句等同于x=x-2;执行后，x的值为3
乘赋值“*=”：先乘后赋值。请看下面的例子：int x=5; x *= 2;//这句等同于x=x*2;执行后，x的值为10
除赋值“/=”：先除后赋值。请看下面的例子：int x=5; x /= 2;//这句等同于x=x/2;执行后，x的值为2
取余赋值“%=”：先取余后赋值。请看下面的例子：int x=5; x %= 2;//这句等同于x=x%2;执行后，x的值为1
与其他运算符从左向右计算不同，赋值运算符从右向左计算。

C#的运算符优先级
前面我们学习了那么多运算符，如果编程中同时使用了多个运算符，到底哪一个会先运算呢？这就是优先级的问题。C#运算符的优先级请参考下面的顺序：
①括号。学数学的时候我们就知道，要先计算括号里面的内容。C#语言也是一样，如果有多层括号，要从里向外计算。括号优先级最高。
②一元运算符。有些运算符两边有2个操作数，比如2+3、6%5等等，这些叫做二元运算符。只有一个操作数的叫做一元运算符，它们的优先级高于二元运算符。一元运算符包括：++(自加) 、 --（自减） 、 !（逻辑非）。
③*（乘）、/（除）、%（取余）。
④+（加）、-（减）。
⑤>（大于）、<（小于）、>=（大于等于）、<=（小于等于）。
⑥==（等于）、!=（不等于）。
⑦&&（逻辑与）。
⑧||（逻辑或）。
⑨赋值运算符。包括：=、+=、-=、*=、/=、%=。
另外，还需要注意一点：优先级相同的运算符从左向右计算（赋值运算符相反）。

请看下面这段代码：
bool b = 20 - (15 - 8) * 2 > 10 && (2 % 2 * 2 + 2) > 2;
Console.WriteLine(b);
分析：首先计算优先级最高的括号，(15-8)得到7，(2%2*2+2)则需要先计算%和*，后算+，结果是2，表达式就变成了：bool b=20-7*2>10&&2>2;
接下来优先级最高的是7*2，然后是减法，变成：bool b=6>10&&2>2;
继续计算两个大于号，得到：bool b=false&&false;
最后的结果当然是false.

外层的if (userName == "admin") 会被首先判断，如果为 false ，就会输出“用户名错误！”；如果为 true ，再判断内层的if (password == "bj2022")。

C#提供了一种条件运算符，能够代替简单的 if...else 结构。这种条件运算符的语法如下：
条件表达式 ? 分支1 : 分支2
?: 就是条件运算符，可以看到它有3个操作数，所以又被称为三元运算符。它的运算逻辑是：当条件表达式为 true 时，执行分支1；当条件表达式为 false 时，执行分支2。

if...else 之外，C#中还有一种 switch 条件结构，可以用来对变量进行多个分支的等值判断。语法如下：
switch(变量){
case 常量1:分支1;break;
case 常量2:分支2;break;
...
default:分支n;break;
}

（变量）与每一个 case 后面的常量进行等值比较，如果相等，就执行对应的分支。
执行分支以后， break 关键字会使 switch 结构中止，不会再判断后面的常量。如果变量与所有的常量都不相同，则执行 default 后面的分支。

switch 中的（变量）只能是3种类型：整型(如 int )、字符型( char )、字符串类型( string )。

C#中还有一种非常有用的 for 循环，特别适合于“已知循环次数”的循环。
while 循环有的变量声明、循环条件、变量自加， for 循环一个也不缺，但是 for 循环把这些跟循环次数有关的元素都放在 ( ; ; ) 中，使得{}中的循环体更加纯粹，程序结构更加清晰。
*  for 循环 ( ; ; ) 中的两个分号是不能缺少的。
for 循环运行时，首先进行变量声明和赋值；接下来判断循环条件，若条件为 true ，则执行循环体一次，若条件为 false ，则结束循环；执行循环体后，进行变量自加。然后会进入下一次循环。

C#中， do...while 循环也是一种常用的循环结构。循环结构各部分运行顺序如下：
do{
循环体
变量自加
}while(循环条件);
do...while 循环第一次执行循环体是没有经过条件判断的，也就是说会无条件的执行一次循环体，此后的逻辑顺序就与while循环相同了——先判断条件，条件为true再执行循环体一次。

循环中可以应用 continue 关键字中止一次循环，直接进入下一次。

前面学习 switch 结构时，我们曾经遇到过 break 关键字， break 在 switch 结构的作用是“跳出 switch 结构”。
break 关键字还可以用在循环中，作用是“结束循环”。

在一个循环体中包含另一个循环，称为“嵌套循环”。当2个循环嵌套的时候，外层循环体执行一次，内层循环体执行 n 次（ n 是内层循环的次数）。

编程中有这样一种情形：我们需要存储多个同类型数据。比如，保存 1600 个学生的年龄。是否需要声明 1600 个 int 类型的变量？过了一年，学生们长了 1 岁，是否需要给每个变量重新赋值？这件事情，想想就怕怕。
好在C#中有一种数组，专门存储一组相同类型的数据。数组的声明和初始化语法如下：
<b>数据类型[ ] 数组名 = new 数据类型[长度]; </b>
注意：数组名像变量名一样要遵循标识符的命名规则；长度必须是整数

因为初始化数组时在 [ ] 中声明的长度为 3 。既然都在数组 y 中，所以 3 个变量（应该叫数组元素）的名字都叫 y ，为了区分它们，按照顺序给它们加上索引 [0]、[1]、[2] 。
请注意：数组的索引从 0 开始递增。那么，数组 y 中 3 个元素的名字就变成了 y[0]、y[1]、y[2] 。
最后再注意一点：数组经过初始化以后，数组元素有默认的初始值， double 类型为 0.0 ， int 类型为 0 ， char 类型为 'a' ， bool 类型为 false ， string 类型为 null 。
数组元素的赋值与普通变量相同。

如何知道一个数组的长度呢？ 数组.Length 属性会返回数组的长度（即数组元素的个数）。

数组，可以用来存储相同类型的多个数值。声明并初始化数组的语法：
数据类型[] 数组名 = new 数据类型[]{初始值1,初始值2,...初始值3};
数组元素用索引来区分，索引从 0 开始。
数组的 Length 属性返回数组的长度，即数组元素的个数。

循环访问一组数据，从中找出符合条件的数据，这样的算法叫做查找。
写查找的算法，需要做 2 件事，一是写循环访问每一个数据，二是对每一个数据进行验证。这样，就需要写 2 个“条件”：循环条件和筛选条件。

如上例，循环条件是x<=10，筛选条件是x%2==0。初学者常见的错误是把 2 个条件都写在循环条件里，比如把循环条件写成 x<=10 && x%2== 0 ，请注意甄别：循环条件必须能够遍历每一个数据，如果你写的循环条件会漏掉某些数据，或者循环没有能够正常运行，请检查是不是把筛选条件也写在循环条件里了。

查找算法，主要有 2 个步骤：
1、使用循环访问数组中的每一个元素
2、在循环体中设置筛选条件，打印符合条件的元素

一组数据中只要有一个符合条件，就可以认为“有符合条件的数据”；但只有一组数据中每一个都不符合条件，才能认为“没有符合条件的数据”——一个相等即为"有"，全都不等才是"无"。

变量 hasNbr 起到了关键作用：记录筛选结果。它的初始值为 false ，表示没有，如果循环中找到了相等的数据，再修改 hasNbr 的值为 true ，表示有。循环结束后，只要看看变量 hasNbr 是 true 还是 false ，就知道循环中是否修改过。

for 循环使我们可以通过索引访问数组元素；而 foreach 循环则可以不依赖索引而读取每一个数组元素。

使用 foreach 的语法：
foreach(数据类型 迭代变量名 in 数组名) 注：数据类型必须与数组类型相同
{
使用迭代变量
}
迭代变量 x 只能用于读取数组 num 中的值，但是不能给数组元素赋值，如果尝试给 x 赋值，则会有下面的错误提示：

了解了 foreach 循环的语法，你可能会有疑问：好像 foreach 循环能做的 for 都能做， foreach 存在的意义是什么呢？其实，C#中还存在一些类似于数组的数据组织方式，它们中有一些是没有元素索引的，对于这些元素，只能通过 foreach 遍历。关于那些更高级的对象，我们留待后面的课程介绍。

C#的二维数组的声明和访问
二维数组，就是以数组作为元素的数组。
总结一下，二维数组这样声明：
int[,] arr = new int[2,3]; //包含2个一维数组，每个一维数组包含3个变量，总共2*3=6个数组元素

二维数组元素这样赋值和打印：
arr[1,0] = 28; //二维数组元素有2个索引，都是从0开始，以arr数组为例，元素索引从[0,0]到[1,2]
Console.Write( arr[1,0] );
我们可以用二维数组管理相关的数据，比如有 4 名同学参加语文和数学两门考试，我们用二维数组存储他们的成绩，每位同学的 2 门课分数，存储在一个一维数组中：

类型转换：score[i]=int.Parse(Console.ReadLine());

调试程序：Visual Studio添加断点，快捷键F9，调试运行快捷键F5，单步执行F10.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            const double Pi = 3.14159265359;
            Console.WriteLine("Hello world!");
            Console.WriteLine(Pi);
            Console.WriteLine((double)3.6);
            Console.WriteLine(9 + "2.2");//num9 transform the string,the result is 92.2
            Console.WriteLine(5 / 10);//result is 0, just save the front

            for (int x = 1; x < 8; x++)//循环7行
            {
                for (int y = 1; y < 8; y++)//循环7列
                {
                    if (x == y || x == (8 - y))//对角线打印O
                    {
                        Console.Write("O");
                    }
                    else
                    {
                        Console.Write(".");//其他位置打印.
                    }
                }
                Console.WriteLine();//换行
            }

            Console.WriteLine("---------------");

            string[,] score = new string[8, 2] { { "吴松", "89" }, { "钱东宇", "90" }, { "伏晨", "98" }, { "陈陆", "56" }, { "周蕊", "60" }, { "林日鹏", "9" }, { "何昆", "93" }, { "关欣", "85" } };
            string name = "";
            string result = "0";
            for (int i = 0; i < score.Length / 2; i++)
            {
                if (String.Compare(score[i, 1], result) > 0)
                {
                    name = score[i, 0];
                    result = score[i, 1];
                }
            }
            //Console.WriteLine("分数最高是的{0}，分数是{1}", name, result);
            Console.WriteLine("分数最高的是" + name + ",分数是" + result);

            Console.WriteLine("---------------");

            string[] name1 = new string[] { "吴松", "钱东宇", "伏晨", "陈陆", "周薇", "林日鹏", "何昆", "关欣" };
            int[] num = new int[] { 89, 90, 98, 56, 60, 91, 93, 85 };
            int temp = 0;
            string temp_name = "";
            for (int i = 0; i < num.Length; i++)
            {
                if (temp < num[i])
                {
                    temp = num[i];
                    temp_name = name1[i];
                }
            }
            Console.WriteLine("The highest score is {0}，score is {1}", temp_name, temp);


            Console.WriteLine("---------------");
            string in_name;
            Console.Write("Please input your name:");
            in_name = Console.ReadLine();
            Console.WriteLine("Hello,{0}!", in_name);
            Console.WriteLine("Hello," + in_name + "!");

            Console.WriteLine("---------------");
            string[] name_shuru = new string[2];
            int[] score_shuru = new int[2];
            for (int i = 0; i < name_shuru.Length; i++)
            {
                Console.Write("Please input the number of " + (i + 1) + " name:");
                name_shuru[i] = Console.ReadLine();
                Console.Write("Please input the number of " + (i + 1) + " score:");
                score_shuru[i] = int.Parse(Console.ReadLine());

            }
            //Calculate the total and average score
            int sum_shuru = 0, avg = 0;
            for (int i = 0; i < score_shuru.Length; i++)
            {
                sum_shuru += score_shuru[i];
            }
            avg = sum_shuru / name_shuru.Length;
            Console.WriteLine("The total score is:" + sum_shuru + ", The average score is:" + avg);

            Console.WriteLine("-----The final project----------");
            string[] final_name = new string[8] { "景珍", "林惠洋", "成蓉", "洪南昌", "龙玉民", "单江开", "田武山", "王三明" };
            int[] final_score = new int[8] { 90, 65, 88, 70, 46, 81, 100, 68 };
            int final_sum = 0, final_avg = 0;
            for (int i = 0; i < final_score.Length; i++)
            {
                final_sum += final_score[i];
            }
            final_avg = final_sum / final_score.Length;
            Console.WriteLine("平均分是" + final_avg + "，高于平均分的有：");
            for (int j = 0; j < final_score.Length; j++)
            {
                if (final_score[j] >= final_avg)
                {
                    int k = j;
                    Console.Write(final_name[k] + " ");
                }
            }

        }
    }
}


1、	面向对象设计思想使用三种基本的设计手段：封装、继承、多态来模拟现实世界的事物。
2、	一个小朋友是对象，多小朋友的特征总结出来就是类。
3、	人这个类有姓名、性别、年龄、身高、爱好等特征。
姓名、性别、年龄、身高是静态特征，它们通常是一个名词，可用字段属性来表示；
而爱好是动态的行为，它是一个动词，难以用文字或数字来描述，可用方法来实现，
例：定义一个关于小朋友的类
class Child
{
		stirng _name; //姓名
		string _sex; //性别
		int _age; //年龄           字段，用来描述小朋友的静态特征
		int _height; //身高

		void PlayBall()          //方法的声明
		{//方法体，方法的实现    方法，用来描述小朋友的动态行为
			//代码略
}
}
创建一个小朋友类的对象，也叫类的实例化，如：
Child xiaoMing=new Child(); //实例化了Child类的对象

实例化对象在Main方法中，类名 对象名=new  类名（）；<br>
Child xiaoming=new Child();
有了对象后可以访问他的字段属性和方法
访问字段：对象名.字段="值";  xiaoming._name="小明";
调用方法：对象名.方法名（）;   xiaoming.PlayBall();
输出字段：对象名.字段    xiaoming._name

public关键字，private关键字

public是公共字段，可以在类外被修改（不安全）
private 是私有字段 无法在类外访问（无法使用）

封装：隐藏对象的信息，留出访问的接口
在C#中，通常使用属性对字段进行封装。
隐藏字段，公开属性
利用get(读)，set(写)
public string 
get{return a}
set{a = value}


class Child
    {
        private string _sex;    //隐藏字段
        public string Sex       //公开属性
        {
            get { return _sex; }     //get,set为访问器   get为读   set为写
            set { _sex = value; }	//如果只有get为只读属性，不能修改
        }
    }

属性封装技巧：
private 数据类型 _字段名称;
public 与上数据类型保持一致 字段名称(首字母大写)
{
	get{ return _字段名称; }//读访问器
	set{ _字段名称 = value; }//写访问器
}
新字段名称在Main中的也要引用出来。

封装快捷键：Ctrl + R + E

将set属性删除就是只读属性，则Main中不能为属性赋值了，想要赋值
1.可以得在Child.cs中为字段直接赋值：private string sex="男";同样的也不能在Main中修改；
2.用构造方法

在set访问器中添加条件，约束性赋值：
public int Age
        {
            get => age;
            set { if (value >= 3 && value <= 7) age = value; }
        }
不合理赋值语句不会执行

定义并调用无参方法：
对象{字段、属性、方法}
使用方法{定义方法——调用方法（声明方法——实例化对象——调用方法）}
声明方法：访问修饰符 返回值 方法名
      例：public viod EatSugar()
                {
                   Console.WriteLine("我是吃糖的方法体");
                }
实例化对象：类名 对象名 = new 类名();
        例：Child child = new Child();
调用方法：对象名.方法名();
      例：child.EatSugar();


方法配置了形式参数的情况下，调用方法的时候就需要传入对应形参个数个类型的实际参数.
程序执行方法的时候，程序跳转到方法的定义位置，实参复制一份给形参，方法体执行完毕，返回到方法调用的位置。

方法的重载：
同一个类中，多个方法名相同，但是参数的类型或数量不同
调用时直接通过传入参数的类型判断调用的是哪个
如果参数类型和数量相同，无法实现重载

